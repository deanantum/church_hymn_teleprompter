<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Select a Hymn</title>
  <style>
    body { font-family: system-ui, sans-serif; background-color: #f3f4f6; color: #1f2937; }
    .shell { max-width: 960px; margin: 2rem auto; padding: 0 1rem; }
    .card { background: #fff; border: 1px solid #e5e7eb; border-radius: 10px; padding: 24px; box-shadow: 0 1px 3px rgba(0,0,0,.05); }
    .row { display: grid; gap: .75rem; }
    label { font-weight: 600; }
    input[type="text"], select { width: 100%; padding: .6rem .7rem; border: 1px solid #d1d5db; border-radius: 8px; box-sizing: border-box; }box-sizing: border-box; }
    .btns { display: flex; flex-wrap: wrap; gap: .5rem; }
    button { padding: .6rem .9rem; border: 1px solid #cbd5e1; border-radius: 8px; background: #f9fafb; cursor: pointer; font-weight: 600; }
    .primary { background: #2b6cb0; color: #fff; border-color: #2b6cb0; }
    .muted { color: #6b7280; font-size: .9rem; }
    .note { margin-top: .5rem; color: #374151; font-size: .95rem; }
    .runlist-container { display: grid; grid-template-columns: 1fr auto 1fr; gap: 1rem; align-items: center; margin-top: 1rem; }
    .list-box { display: flex; flex-direction: column; }
    .transfer-buttons { display: flex; flex-direction: column; gap: 0.5rem; }
    #runlist { list-style: none; padding: 0; margin: 0; max-height: 300px; overflow-y: auto; border: 1px solid #d1d5db; border-radius: 8px; }
    #runlist li { padding: 0.6rem 0.7rem; cursor: grab; border-bottom: 1px solid #e5e7eb; }
    #runlist li:last-child { border-bottom: none; }
    #runlist li.dragging { opacity: 0.5; background: #dbeafe; }
    #runlist li:active { cursor: grabbing; }
    #runlist li.selected { background: #dbeafe; font-weight: 600; }
    .search-container {
     display: flex;
     align-items: center;
     border: 1px solid #d1d5db; /* <-- MOVED from input */
     border-radius: 8px; /* <-- MOVED from input */
     background-color: #fff; /* <-- ADDED to look like input */
     padding-right: 0.3rem; /* <-- ADDED space for the button inside */
     width: 100%;
   }
   #searchBox {
     flex-grow: 1; /* Allow input to fill space */
     padding: .6rem .7rem; /* Keep original padding */
     border: none; /* <-- REMOVED */
     background-color: transparent; /* <-- ADDED */
     outline: none; /* <-- ADDED prevent double outline on focus */
     box-sizing: border-box;
     min-width: 0;
   }
    .clear-search-btn {
     /* position: absolute; <-- REMOVED */
     /* right: 0.5rem; <-- REMOVED */
     padding: 0.2rem 0.5rem;
     border: none;
     background: #f3f4f6; /* Slightly adjust background */
     cursor: pointer;
     font-size: 0.9rem;
     display: none;
     flex-shrink: 0; /* Prevent button shrinking */
     border-radius: 4px; /* Optional rounded corners */
   }
   .search-container:focus-within {
     outline: 2px solid #181028; /* Mimic input focus */
     outline-offset: 1px;
   }
    .clear-search-btn.visible { display: block; }
    .runlist-btns { display: flex; gap: .5rem; margin-top: .5rem; }
    .runlist-btns button { flex: 1; }
    .row > div:first-child {
      /* Calculate width: (100% - gap) / 2 is roughly one '1fr' column */
      /* Adjust percentage slightly if needed */
      width: calc(46% - 0.5rem); /* Example: slightly less than half minus half the gap */
  	}
  </style>
</head>
<body>
  <div class="shell">
  
  
		<div class="card">
      <h1 style="margin-top:0">Hymn Library</h1>
      <p class="muted">Search for songs, add them to the runlist, and then click <strong>Load Runlist</strong>.</p>

      <div class="row" style="margin-bottom: 1rem;"> <div> <label for="searchBox">Search</label>
          <div class="search-container">
            <input id="searchBox" type="text" placeholder="e.g., 19 or We Thank Thee" autocomplete="off"/>
            <button class="clear-search-btn" id="clearSearchBtn">X</button>
          </div>
        </div>
        </div>
      <div class="runlist-container">
        <div class="list-box">
          <label for="songSelect">All Hymns</label>
          <select id="songSelect" size="12" aria-label="Hymn list"></select>
        </div>
        <div class="transfer-buttons">
          <button id="addBtn" aria-label="Add to runlist">&rarr;</button>
          <button id="removeBtn" aria-label="Remove from runlist">&larr;</button>
        </div>
        <div class="list-box">
          <label for="runlist">Runlist (Max 10)</label>
          <ul id="runlist" aria-label="Runlist"></ul>
          <div class="runlist-btns">
            <button class="primary" id="loadBtn">Load Runlist</button>
            <button id="clearRunlistBtn">Clear Runlist</button>
          </div>
        </div>
      </div>
      <div class="note">Tip: Double-click to add/remove. Drag to reorder runlist.</div>
    </div>
    
    
  </div>
  <script>
    const searchBox = document.getElementById('searchBox');
    const songSelectEl = document.getElementById('songSelect');
    const runlistEl = document.getElementById('runlist');
    const loadBtn = document.getElementById('loadBtn');
    const clearRunlistBtn = document.getElementById('clearRunlistBtn');
    const clearSearchBtn = document.getElementById('clearSearchBtn');
    const addBtn = document.getElementById('addBtn');
    const removeBtn = document.getElementById('removeBtn');
    let ALL_SONGS = [];
    let runlist = [];
    let draggedItem = null;

    function saveRunlist() {
      localStorage.setItem('hymnRunlist', JSON.stringify(runlist));
    }

    function loadRunlist() {
      const saved = localStorage.getItem('hymnRunlist');
      if (saved) {
        runlist = JSON.parse(saved);
        renderRunlist();
      }
    }

    async function loadHymnList() {
      try {
        const res = await fetch("data/hymns_English.json");
        if (!res.ok) throw new Error(`Could not load hymn data. Status: ${res.status}`);
        const hymnsData = await res.json();
        ALL_SONGS = Object.keys(hymnsData).map(number => ({
          n: parseInt(number),
          title: (hymnsData[number].title || 'Unknown').trim()
        })).filter(hymn => hymn.title).sort((a, b) => a.n - b.n);
        if (ALL_SONGS.length === 0) {
          throw new Error("No valid hymns found in hymns_English.json");
        }
        renderOptions(ALL_SONGS, songSelectEl);
        songSelectEl.selectedIndex = 0;
        loadRunlist();
      } catch (error) {
        console.error("Error loading hymn list:", error);
        songSelectEl.innerHTML = '<option disabled>Error loading hymns.</option>';
      }
    }

    function renderOptions(list, selectElement) {
      selectElement.innerHTML = '';
      list.forEach(s => {
        const opt = document.createElement('option');
        opt.value = String(s.n);
        opt.textContent = `${s.n} - ${s.title}`;
        selectElement.appendChild(opt);
      });
    }

    function renderRunlist() {
      runlistEl.innerHTML = '';
      runlist.forEach((song, index) => {
        const li = document.createElement('li');
        li.textContent = `${song.n} - ${song.title}`;
        li.dataset.index = index;
        li.draggable = true;
        runlistEl.appendChild(li);
      });
    }

    function addToRunlist() {
      if (songSelectEl.selectedIndex < 0) return;
      const songNumber = songSelectEl.value;
      if (runlist.length >= 10) {
        alert("Runlist is full (max 10 songs).");
        return;
      }
      if (runlist.some(song => String(song.n) === songNumber)) {
        return;
      }
      const songToAdd = ALL_SONGS.find(song => String(song.n) === songNumber);
      if (songToAdd) {
        runlist.push(songToAdd);
        renderRunlist();
        saveRunlist();
      }
    }

    function removeFromRunlist() {
      const selected = runlistEl.querySelector('li.selected');
      if (!selected) return;
      const index = parseInt(selected.dataset.index);
      runlist.splice(index, 1);
      renderRunlist();
      saveRunlist();
    }

		function loadSelection() {
			// Check if the runlist is empty FIRST
			if (runlist.length === 0) {
				// Show an alert if the runlist is empty
				alert("Runlist cannot be empty. Please add songs to the runlist first.");
				return; // IMPORTANT: Stop the function here
			}
		
			// If the runlist is NOT empty, proceed to load it
			const runlistNumbers = runlist.map(song => song.n).join(',');
			location.href = `song.html?runlist=${encodeURIComponent(runlistNumbers)}`;
		
			// NOTE: The old 'else if' part that loaded a single selected song
			// has been removed because this button's specific job is to load the runlist.
		}

    function normalize(s) { return s.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').trim(); }

    function filterAndRenderSongs(query) {
      if (!query) {
        renderOptions(ALL_SONGS, songSelectEl);
        songSelectEl.selectedIndex = 0;
        return;
      }
      const normalizedQuery = normalize(query);
      const filtered = ALL_SONGS.filter(song => {
        const songText = normalize(`${song.n} - ${song.title}`);
        return songText.includes(normalizedQuery);
      });
      renderOptions(filtered, songSelectEl);
      if (filtered.length > 0) {
        songSelectEl.selectedIndex = 0;
      }
      clearSearchBtn.classList.toggle('visible', query.length > 0);
    }

    searchBox.addEventListener('input', (e) => filterAndRenderSongs(e.target.value));
    searchBox.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        addToRunlist();
      }
    });

    addBtn.addEventListener('click', addToRunlist);
    removeBtn.addEventListener('click', removeFromRunlist);
    loadBtn.addEventListener('click', loadSelection);
    clearRunlistBtn.addEventListener('click', () => {
      runlist = [];
      renderRunlist();
      saveRunlist();
    });
    clearSearchBtn.addEventListener('click', () => {
      searchBox.value = '';
      filterAndRenderSongs('');
      searchBox.focus();
      clearSearchBtn.classList.remove('visible');
    });

    songSelectEl.addEventListener('dblclick', addToRunlist);
    runlistEl.addEventListener('click', (e) => {
      const li = e.target.closest('li');
      if (!li) return;
      runlistEl.querySelectorAll('li').forEach(l => l.classList.remove('selected'));
      li.classList.add('selected');
    });
    runlistEl.addEventListener('dblclick', removeFromRunlist);

    // Drag and Drop for Runlist
    runlistEl.addEventListener('dragstart', (e) => {
      const li = e.target.closest('li');
      if (!li) return;
      draggedItem = li;
      li.classList.add('dragging');
      e.dataTransfer.setData('text/plain', li.dataset.index);
    });

    runlistEl.addEventListener('dragend', (e) => {
      if (draggedItem) {
        draggedItem.classList.remove('dragging');
        draggedItem = null;
      }
      runlistEl.querySelectorAll('li').forEach(l => l.classList.remove('drag-over-top', 'drag-over-bottom'));
    });

    runlistEl.addEventListener('dragover', (e) => {
      e.preventDefault();
      const li = e.target.closest('li');
      if (!li || li === draggedItem) return;
      const rect = li.getBoundingClientRect();
      const midpoint = rect.top + rect.height / 2;
      if (e.clientY < midpoint) {
        li.classList.remove('drag-over-bottom');
        li.classList.add('drag-over-top');
      } else {
        li.classList.remove('drag-over-top');
        li.classList.add('drag-over-bottom');
      }
    });

    runlistEl.addEventListener('dragleave', (e) => {
      const li = e.target.closest('li');
      if (li) {
        li.classList.remove('drag-over-top', 'drag-over-bottom');
      }
    });

    runlistEl.addEventListener('drop', (e) => {
      e.preventDefault();
      const li = e.target.closest('li');
      if (!li || !draggedItem) return;
      const draggedIndex = parseInt(draggedItem.dataset.index);
      const targetIndex = parseInt(li.dataset.index);
      li.classList.remove('drag-over-top', 'drag-over-bottom');
      const rect = li.getBoundingClientRect();
      const midpoint = rect.top + rect.height / 2;
      let insertIndex = e.clientY < midpoint ? targetIndex : targetIndex + 1;
      if (draggedIndex < targetIndex && insertIndex > draggedIndex) {
        insertIndex--;
      }
      const draggedSong = runlist.splice(draggedIndex, 1)[0];
      runlist.splice(insertIndex, 0, draggedSong);
      renderRunlist();
      saveRunlist();
    });

    document.addEventListener('DOMContentLoaded', loadHymnList);
  </script>
</body>
</html>
